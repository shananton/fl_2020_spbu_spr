2.  Докажем, что достаточно разделить применения первого и второго правила:
    ```
    S -> aSbbbb | T
    T -> aaaTbb | c
    ```
    
    Пусть дана строка, порождаемая этой грамматикой, и в ней `x` букв `a` и `y` букв `b`.
    поскольку оба правила добавляют по 5 букв (`a` и `b`) в строку, мы знаем, что их нужно применить 
    в сумме `s := (x + y)/5` раз.
    
    Но тогда, посмотрев на `a` можно понять, что второе правило применили ровно `v := (x - s) / 2` раза,
    а первое - `u := s - v` раз.

4.  Обозначим L язык, порождаемый `F -> a | bF | cFF`


    Посмотрим на грамматику:
    ```
    K -> aM | cM
    M -> aK | bK | ε
    ```
    Назовем строку b-чередующейся, если у нее на нечетных позициях (нумерация с 1) находятся только `b` и `a`,
    а на четных - `c` и `a`.
    
    Назовем строку c-чередующейся, если у нее на нечетных позициях (нумерация с 1) находятся только `c` и `a`,
    а на четных - `b` и `a`.
    
    Тогда заметим, что эта грамматика задает ровно c-чередующиеся строки нечетной длины.
    
    Составим грамматику для пересечения, используя нетерминалы V<sub>even/odd</sub><sup>b/c</sup>.
    Идея в том, что, например, из нетерминала V<sub>even</sub><sup>b</sup> можно получить
    ровно любую b-чередующуюся строку четной длины, лежащую в L.
    
    Итоговая грамматика (стартовый нетерминал - V<sub>odd</sub><sup>c</sup>):
    
    V<sub>odd</sub><sup>c</sup> -> a | c V<sub>even</sub><sup>b</sup> V<sub>even</sub><sup>b</sup> |
    c V<sub>odd</sub><sup>b</sup> V<sub>odd</sub><sup>c</sup>
    
    V<sub>odd</sub><sup>b</sup> -> a | b V<sub>even</sub><sup>c</sup>
    
    V<sub>even</sub><sup>c</sup> -> c V<sub>even</sub><sup>b</sup> V<sub>odd</sub><sup>b</sup> |
    c V<sub>odd</sub><sup>b</sup> V<sub>even</sub><sup>c</sup>

    V<sub>even</sub><sup>b</sup> -> b V<sub>odd</sub><sup>c</sup>
    
    Должно быть понятно, что грамматика задает нужное пересечение. Теперь поймем, что она однозначна.

    Можно думать, что строчки, соответствующие `F -> a | bF | cFF` задают 'pre-order' обход корневого дерева,
    где у каждой вершины 0, 1 или 2 сына. `a` соответствует листу, `b` - вершине с одним сыном, `c` - с двумя.
    Например, строчка `cbacaa` соответствует дереву:
    ```
     c
    / \
    b c
    | |\
    a a a
    ```
    
    Тогда если нам дана строчка из пересечения, по ней мы можем восстановить исходное дерево, и затем однозначно восстановим
    разбор, зная четность размера левого сына.
